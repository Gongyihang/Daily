TCP/IP协议族体系  
四层：
应用层：负责应用层的逻辑。譬如ping应用程序、telnet协议、DNS协议
传输层：为两台主机提供端到端的通信，与网络层使用的逐跳通信方式不同，只关心起始端和目的端，不在乎数据包的中转过程。主要有三个协议：TCP、UDP和SCTP协议。
        TCP：为应用层提供可靠的、面向连接的和基于字节流的服务，使用超时重传、数据确认等方式确保数据包被正确地发送到目的端。拥塞控制。
        2MSL原因：1.可靠地终止TCP连接（如果客户端最后用来确认终止连接的报文丢失了，服务端会重传FIN报文段，来保证让客户端收到） 2.保证让迟来的TCP报文有足够的时间被识别并丢弃。（假如不等待2MSL，在Linux系统上，一个TCP不能被打开多次，如果立马close，应用程序立马建立了一个和原来相似的连接，拥有同样的IP和端口，那这个连接可能会收到属于原来连接的，迟到的报文。这显然是不应该发生的。）TCP报文段的最大生存时间是MSL，所以坚持2MSL会保证两个传输方向上尚未收到的迟到的TCP报文都已经消失，或者被丢弃。因此一个连接的新的化身可以在2MSL的时间之后安全地建立，二绝对不回收到属于原来连接的应用程序数据。一般建议2min。
        超时重传：每次重传时间都会增加一倍。  虽然超时会导致TCP报文段重传，但TCP报文的重传可以发生在超时之前，即快重传。  
        拥塞控制：包含四个部分，慢启动、拥塞避免、快速重传和快速恢复。判断拥塞发生的依据有两个：a.传输超时，或者说TCP重传定时器溢出（慢启动，拥塞避免）。b.接收到重复的确认报文段（快重传，快恢复）。  
        UDP：为应用层提供不可靠、无连接和基于数据报的服务，不可靠意味着无法保证数据从发送端正确传送到目的端。如果目的端发现失败，UDP只是简单通知应用程序发送失败。 
        无连接的，不保持长连接，每次都要指明接收端的地址。基于数据报，数据报是有长度的，接收端必须以该长度为最小单位将其内容一次性读出，否则将截断。
网络层：数据包的选路和转发，最核心的是IP协议。ICMP协议是IP协议的重要补充，主要用于检测网络连接。  
数据链路层：数据在物理媒介上的传输，ARP协议和RARP协议，他们实现了IP地址到物理地址MAC之间的转换  

http状态码：  
100 continue  
200 成功  
3xx 重定向  
4xx 客户端错误  
5xx 服务器错误  
 
I/O模型分为阻塞和非阻塞  
阻塞IO：针对阻塞IO执行的系统调用可能会因为无法立即完成而被操作系统挂起，直到等待事件发生为止。（socket中的accept、send、recv和connect都是阻塞的）  
非阻塞IO：针对非阻塞执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。  

显然，我们只有在事件已经发生的情况下操作非阻塞IO，才能提高程序效率，因此，非阻塞IO通常要和其他IO通知机制一起使用，比如IO复用和SIGIO信号  
Linux下通常使用地IO复用函数是select、poll和epoll，其实IO复用函数本身是阻塞的，它们能提高程序的效率是原因是因为它们能同时监听多个IO事件的能力。  

同步IO是指IO的读写操作，都是在IO事件发生之后，要求用户代码自行执行IO操作（将数据从内核缓冲区读入用户缓冲区，或者将数据从用户缓冲区写入内核缓冲区）。  
异步IO是指用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO操作完成之后，内核通知应用程序的方式。异步IO的读写操作总是立即返回，而不论IO是否阻塞，因为真正的读写操作已经有内核接管。（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）  
理解：同步IO向应用程序通知的是IO就绪事件，而异步IO向应用程序通知的是IO完成事件。  
  
