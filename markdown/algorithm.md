1. 快速求三个有序数组的交集                  leetcode 349 350
2. 内存复制把初始化的A空间的东西复制到B空间  
3. strcpy实现  
4. 有序数组合并  leetcode 88
5. topK  215
6. 翻转二叉树  226
7. 快速排序  
8. 简易版的shared_ptr  
9. 单例设计模式  
10. 二叉树层序遍历  
11. 二叉搜索树定义、序列化、反例化一个二叉搜索树  
12. 实现一个循环队列  
13. 将一个IP地址转化为十进制  
14. 场景题：10亿个数字，找出前100个最大的数字（我说用hash+堆来做）,（面试官：利用虚拟内存，将部分数字加载到内存中，然后建立大根堆）  
15. 无序数组，求所有两个数之和为0的组合  
16. 无序数组，求所有三个数之和为0的组合  
17. 求丑数  
18. 如何解决高并发？从前端、后端、存储、网络四个角度解释一下  
19. 翻转链表、K个一组翻转链表  
20. 数组右移K位  
21. 一个数组，求和位M的数据对，要求把结果返回  
22. 判断一个字符串是不是IP地址  
23. 数组长度为N，数据是1-N,判断是否有重复数据?  要求时间复杂度O(n),空间复杂度O(1)
（剑指原题，但注意数据是1-N，数组下标是0-N-1,所以写的过程对应下标需要稍微转换）
24. 海量数据，怎么统计出字符串出现的个数?（假设1000G数据，只有4G内存大小)  
25. 括号是否有效（栈）  
26. 最长连续公共子串  
27. 完全二叉树703结点，求叶子结点、层数   
28. 查询链表是否有环  
29. 最大公约数，最小公倍数  
30. 二叉树的先序中序后序、给出先中，写出后序  
31. 先序的递归和非递归  
32. 递归查找数组的最大值  
33. 一个有效的IP地址转化为数字数组  
34. 层序遍历  
35. 场景题，10亿数字中找出一个不同的数字  
1）方案 1：采用 2-Bitmap（每个数分配 2bit，00 表示不存在，01 表示出现一次，10 表示多次，11 无意义）进行，共需内存 2^32 * 2 bit=1 GB 内存，还可以接受。然后扫描这 2.5亿个整数，查看 Bitmap 中相对应位，如果是 00 变 01，01 变 10，10 保持不变。所描完事后，查看 bitmap，把对应位是 01 的整数输出即可。 2）方案 2：也可采用与第 1 题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。
36. 无序数组的中位数  
37. 回文链表（首先判断回文字符串的思路是从中心向两边扩展，或者是两边向中心进行遍历。（不考虑奇偶的话）链表后序遍历法，使用递归判断当前node是否为null）。或者通过双指针，快慢指针，找到链表的中点，再对slow后面的链表进行reverse遍历。注意这里会改变链表原始状态。
```cpp
// 左侧指针
ListNode left;

boolean isPalindrome(ListNode head) {
    left = head;
    return traverse(head);
}

boolean traverse(ListNode right) {
    if (right == null) return true;
    boolean res = traverse(right.next);
    // 后序遍历代码
    res = res && (right.val == left.val);
    left = left.next;
    return res;
}
```


算法分类：

动态规划（东哥）
斐波那契数列  
直接用递归、带备忘录的递归、改写dp、存中间变量的dp（空间复杂度降为O（1））  



