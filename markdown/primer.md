# 第七章 类
类的基本思想是数据抽象和封装。
数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。
类的接口包括用户所能执行的操作。
类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用而无法访问实现部分。


# C++的关键字
## const关键字
[C++笔记 · C++关键字 - const](https://zhuanlan.zhihu.com/p/27919970)

1. const 修饰类的成员变量，表示成员常量，不能被修改。  
2. const 修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。  
3. 如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。  
4. const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。  
5. 类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。

## static关键字  
1. static 局部变量 将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中
2. static 全局变量 表示一个变量在当前文件的全局内可访问
3. static 函数 表示一个函数只能在当前文件中被访问
4. static 类成员变量 表示这个成员为全类所共有
5. static 类成员函数 表示这个函数为全类所共有，而且只能访问静态成员变量

#### 类的static变量在什么时候初始化？函数的static变量在什么时候初始化？
类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。  


static是初学者经常搞错的概念之一，static定义的变量在程序初始化的时候会初始化在静态数据区，程序运行期间bai完全不变，是指这个区域不变，而内容是可以改变的。换句话说，static只是指定将其存储在静态存储区。  
不同于一般变量，一般变量在运行时候由程序分配内存，而静态变量编译的时候就将分配内存，比如你的问题中，a将被赋值为3，然后，如果你在程序中写a=a+1；a就会变成4，静态变量和一般变量唯一的不同就是整个程序运行期间都将存在。她所在的内存不会被释放。  
这一点跟const关键字不一样，const关键字定义的是只读变量，一经赋值，再也不能改变了。但是const也是初学者经常搞错的概念之一，const代表只读变量，而不是常量，常量通常是用enum或者宏来定义的~  
然后其实static主要的作用并不是来定义什么静态变量什么的，况且他也做不到这点。static最重要的作用是控制元素的作用域。被static的变量或者方法，将是只有本文件可见的！  

## sizeof关键字
[C++ sizeof关键字的使用总结](https://blog.csdn.net/sinat_20265495/article/details/51622990)

**1.定义**
 
 sizeof是一个操作符（operator）。其作用是返回一个对象或类型所占的内存字节数。 其返回值类型为size_t。（size_t在头文件stddef.h中定义，它依赖于编译系统的值，一般定义为 typedef unsigned int size_t;）

**2.语法**
```c++
//sizeof有三种语法形式：
sizeof (object);  //sizeof (对象)
sizeof object;   //sizeof 对象
sizeof (type_name);  //sizeof (类型)
/*
对象可以是各种类型的变量，以及表达式
（一般sizeof不会对表达式进行计算）。
sizeof对对象求内存大小，最终都是转换为对对象的数据类型进行求值。
sizeof (表达式); //值为表达式的最终结果的数据类型的大小
*/
```
例子：
```c
int i;  
sizeof(int); //值为4  
sizeof(i); //值为4，等价于sizeof(int)  
sizeof i; //值为4  
sizeof(2); //值为4，等价于sizeof(int)，因为2的类型为int  
sizeof(2 + 3.14); //值为8，等价于sizeof(double)，因为此表达式的结果的类型为double  
char ary[sizeof(int) * 10]; //OK，编译无误  
```
**3.基本数据类型的sizeof**

这里的基本数据类型是指short、int、long、float、double这样的简单内置数据类型。
由于它们的内存大小是和系统相关的，所以在不同的系统下取值可能不同。

**4.结构体的sizeof**

结构体的sizeof涉及到字节对齐问题。

为什么需要字节对齐？

计算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多花指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，依次类推。

这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。
字节对齐的细节和编译器的实现相关，但一般而言，满足三个准则：

1） 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。

2） 结构体的每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节（internal adding）。

3） 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员后加上填充字节（trailing padding）。

注意：空结构体（不含数据成员）的sizeof值为1。

试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。

例子：
```c
struct S1
{
    char a;
    int b;
};
sizeof(S1);//值为8，字节对齐，在char之后会填充3个字节。
struct S2
{
    int b;
    char a;
};
sizeof(S2); //值为8，字节对齐，在char之后会填充3个字节。
struct S3
{
};
sizeof(S3); //值为1，空结构体也占内存。
```

**5.联合体的sizeof**
```c
/*结构体在内存组织上市顺序式的，联合体则是重叠式，各成员共享一段内存；所以整个联合体的sizeof也就是每个成员sizeof的最大值。
例子：
*/
union u  
{  
    int a;  
    float b;  
    double c;  
    char d;  
};  
sizeof(u); //值为8
```
**6.数组的sizeof**
```c
/*数组的sizeof值等于数组所占用的内存字节数。
注意：1）当字符数组表示字符串时，其sizeof值将’/0’计算进去。
2）当数组为形参时，其sizeof值相当于指针的sizeof值。
例子1：：
*/
char a[10];  
char n[] = "abc";   
cout<<"char a[10]"<<sizeof(a)<<endl;//数组，值为10  
cout<<"char n[] = /"abc/""<<sizeof(n)<<endl;
//字符串数组，将'/0'计算进去，值为4
void func(char a[3])  
{  
    int c = sizeof(a); //c = 4，因为这里a不在是数组类型，而是指针，相当于char *a。  
}  
void funcN(char b[])  
{  
    int cN = sizeof(b); //cN = 4，理由同上。  
}
```
**7.指针的sizeof**
```c
/*指针是用来记录另一个对象的地址，所以指针的内存大小当然就等于计算机内部地址总线的宽度。
在32位计算机中，一个指针变量的返回值必定是4。
指针变量的sizeof值与指针所指的对象没有任何关系。
例子：
*/
char *b = "helloworld";  
char *c[10];  
double *d;  
int **e;  
void (*pf)();    
cout<<"char *b = /"helloworld/"     "<<sizeof(b)<<endl;
//指针指向字符串，值为4  
cout<<"char *b                      "<<sizeof(*b)<<endl; 
//指针指向字符，值为1  
cout<<"double *d                    "<<sizeof(d)<<endl;
//指针，值为4  
cout<<"double *d                    "<<sizeof(*d)<<endl;
//指针指向浮点数，值为8  
cout<<"int **e                      "<<sizeof(e)<<endl;
//指针指向指针，值为4  
cout<<"char *c[10]                  "<<sizeof(c)<<endl;
//指针数组，值为40  
cout<<"void (*pf)();                "<<sizeof(pf)<<endl;
//函数指针，值为4  
```
**8.函数的sizeof**
```c
/*sizeof也可对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。
对函数求值的形式：sizeof(函数名(实参表))
注意：1）不可以对返回值类型为空的函数求值。
2）不可以对函数名求值。
3）对有参数的函数，在用sizeof时，须写上实参表。
例子：
*/
#include <iostream>  
using namespace std;  
float FuncP(int a, float b)  
{  
     return a + b;  
}  
int FuncNP()  
{  
     return 3;  
}  
void Func()  
{  
}  
int main()  
{  
    cout<<sizeof(FuncP(3, 0.4))<<endl; //OK，值为4，sizeof(FuncP(3,0.4))相当于sizeof(float)  
    cout<<sizeof(FuncNP())<<endl; //OK，值为4，sizeof(FuncNP())相当于sizeof(int)  
    /*cout<<sizeof(Func())<<endl; //error，sizeof不能对返回值为空类型的函数求值*/  
    /*cout<<sizeof(FuncNP)<<endl; //error，sizeof不能对函数名求值*/  
}     
```

# C++的多态  

一个对象具备多种形态，也可以理解为事物存在的多种体现形态。（ex：父类的引用类型变量指向了子类对象，或者是接口的引用类型变量指向了接口实现类的对象）  

虚函数就是用来处理多态的。  
动态多态的实现是, 父类的指针或引用, 调用父类或子类的同一个接口, 即同名虚函数, 如果子类实现了虚函数重写, 就可以实现多态, 实质上就是调用子类或父类的同一个接口, 实现不同的方法, 指向谁调谁

#### 虚函数
具体的实现是通过虚函数来实现的, C++中, 如果一个类中有虚函数, 那么类的对象模型中就会维护一个虚表指针,指向一个虚表, 虚表就是虚函数表, 是一个函数指针数组, 存储的是类中所有虚函数的函数指针, 当子类继承父类后, 子类也继承了父类的虚表, 如果子类对父类的同名虚函数重写, 子类会把重写了父类的虚函数的函数指针存储到自己的虚表中,  覆盖掉虚表中对应父类虚函数的函数指针。

然后, 当父类的指针或引用调用虚函数时, 会在虚表中取出函数指针, 指向子类时, 取出的是子类的虚函数的函数指针, 指向父类时, 调用的是父类的虚函数的函数指针.

```cpp
#include <cstdlib>
#include <iostream>
#include <stdio.h>
 
using namespace std;
 
class Parent
{
    public:
        virtual void print()
        {
            printf("I am parent\n");
        }    
};
 
class Child : public Parent
{
    public:
        void print()
        {
            printf("I am Children\n");
        }    
};
 
void run(Parent *p)
{
    p->print();    
}
int main(int argc, char *argv[])
{
    Parent parent;
    Child child;
    
    run(&parent);
    run(&child);
    
    
    cout << "Press the enter key to continue ...";
    cin.get();
    return EXIT_SUCCESS;
}
```

多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数，从上例代码运行的结果看，系统成功的分辨出了对象的真实类型，成功的调用了各自的重载成员函数。  

虚函数的定义要遵循以下重要规则：   

1.如果虚函数在基类与派生类中出现，仅仅是名字相同，而形式参数不同，或者是返回类型不同，那么即使加上了virtual关键字，也是不会进行滞后联编的。 

2.只有类的成员函数才能说明为虚函数，因为虚函数仅适合用与有继承关系的类对象，所以普通函数不能说明为虚函数。 

3.静态成员函数不能是虚函数,因为静态成员函数的特点是不受限制于某个对象。 

4.内联(inline)函数不能是虚函数，因为内联函数不能在运行中动态确定位置。即使虚函数在类的内部定义定义，但是在编译的时候系统仍然将它看做是非内联的。 

5.构造函数不能是虚函数，因为构造的时候，对象还是一片位定型的空间，只有构造完成后，对象才是具体类的实例。 

6.析构函数可以是虚函数,而且通常声名为虚函数。 

同时需要了解多态的特性的virtual修饰，不单单对基类和派生类的普通成员 函数有必要，而且对于基类和派生类的析构函数同样重要！！！

# C++多态  
[C++ 多态详解](https://www.cnblogs.com/dormant/p/5223215.html)  

# C++构造函数和析构函数  
构造函数的作用：用于新建对象的初始化工作。

析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等。

每当创建对象时，需要添加初始化代码时，则需要定义自己的构造函数；

而对象撤销时，需要自己添加清理工作的代码时，则需要定义自己的析构函数。

#### 为什么要把父类的析构函数定义成虚函数?
写成虚的是为了在实现多态的时候不造成内存泄露,如果基类析构函数前不加vitual，派生类对象被销毁后，只会调用基类的析构函数，而不会去调用派生类的析构函数。 

在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。  

#### 深拷贝和浅拷贝的区别  
深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。  
假设B复制了A，修改A的时候，看B是否发生变化：  

如果B跟着也变了，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）  

如果B没有改变，说明是深拷贝，自食其力！（修改堆内存中的不同的值）  

浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，  

深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，  
使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。  

浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。  

深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。  

##### 如果一个函数传入一个对象，那么这是浅拷贝还是深拷贝？  
如果使用的是引用或指针不会发生拷贝，如果传入的类没有实现拷贝构造函数则是浅拷贝，如果实现了拷贝构造函数则看实现的拷贝构造函数是浅拷贝还是深拷贝。  

# C语言里的指针是什么？  
指针是一种保存变量地址的变量。实际上指针不一定是变量，也有常量指针，不过一般都说指针是指针变量的简称。所以上述表达没有什么问题。  

我们知道，基本的数据类型包括int、char和double等。在C语言中，还有一种类型为指针类型~。指针类型不是单独存在的，它是由其他类型派生而来的。也就是说，有个指针变量，其类型为，“指向int的指针类型”或者“指向double的指针类型”。因为先有了“指针类型”，所以有了“指针类型的变量”和“指针类型的值”。“指针类型”是类型，所以和int类型、double类型一样，存在“指针类型的变量”和“指针类型的值”。但是要命的是，“指针类型”、“指针类型的变量”和“指针类型的值”经常被简单(naive)的统称为“指针”。  
这里的“指针类型的值”实际上也就是内存的地址。

### 指针常量与常量指针  
const关键字
指针常量和常量指针都离不开const关键字，我们先来了解一下什么是const关键字，const被用来定义常量，如果将一个变量加上const关键字，则被修饰的变量的值将无法改变。这个变量的值只能被访问，无法被修改。const关键字可以修饰变量或者指针。

下面是const修饰变量的用法：

const int a = 6;

或者 int const a = 6；

此时变量a的值无法改变，只能访问，不能改写。

指针常量  
指针本身是一个常量，不能更改指针指向的地址，只能更改指针指向地址的值。  
常量指针  
常量指针指的是一个常量，所以指针指向的值是不能改变的，但是指针指向的地址是可以改变的。  
区别：  
注意指针常量和常量指针的区别，指针常量只能改变值，不能改变地址，常量指针只能改变地址，不能改变值。  
如果要想值和地址都不改变可以同时在前后都加上const关键字。  

# C++的三大特性
即面向对象的三大特性，封装继承多态。
![](https://iknow-pic.cdn.bcebos.com/5366d0160924ab189ad11b2036fae6cd7a890be5?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)
#### 封装
所谓封装就是将某些东西包装盒隐藏起来，让外界无法直接使用，只能通过某些特定的方式才能访问。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是通过外部接口以及特定的访问权限来使用类的成员。  

例如，下例中时一个动物类，我们把数据和功能封装起来。　
```cpp
class Animal
{
public: //这就是公共成员,外部的接口
    void SetAnimalName(string strname);
    void ShowAnimalName();
private: //这是私有成员，外部是无法访问到的
    string m_strName;
};
```

#### 继承
继承是面向对象的一个重要概念，如果一个类B继承自另一个类A，就把这个类B称为“A的子类”，而把A称为“B的父类”。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码，在令子类继承父类的同时，可以重新定义某些属性，并重新某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能。  
继承是指一个对象直接使用另一个对象的属性和方法，事实上我们遇到的很多事物都有继承的含义，例如，若把动物看做一个实体，他可以分成很多个子实体，如：猫、狗、鸡等等，这些字实体都具有动物的特性，因此，动物是它们的“父亲”，而这些子实体则是动物的“孩子”。   

#### 多态  
多态可以使我们以相同的方式处理不同类型的对象，我们可以使用一段代码处理不同类型的对象，只要他们继承/实现了相同的类型。这样我们没有必要为每一种类型的对象编写相同的逻辑，极大的提高了代码的重用。其实，用简单的一句话来形容就是：多态性，允许将子类类型的指针赋值给父类类型的指针，多态性在C++中是通过虚函数实现的。虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”，或者称为“重写”。子类重写父类中虚函数时，即使不用virtual声明，该重载函数也是虚函数。  
```cpp
#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
using namespace std;

class Father
{
public:
    void Face()
    {
        cout << "Father's face" << endl;
    }

    virtual void Say()
    {
        cout << "Father say hello" << endl;
    }
};


class Son:public Father
{
public:
    void Say()
    {
        cout << "Son say hello" << endl;
    }
};

void main()
{
    Son son;
    Father *pFather=&son; // 隐式类型转换
    pFather->Say();
}
```
输出的结果为：

Son say hello  

#### 为什么构造函数不能为虚函数？
虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。  

#### 为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？
首先析构函数可以为虚函数，而且当要使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。
举例说明：
子类B继承自基类A；A *p = new B; delete p;  
1） 此时，如果类A的析构函数不是虚函数，那么delete p；将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。  
2） 如果类A的析构函数是虚函数，delete p; 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。
补充： B *p = new B; delete p;时也是先调用B的析构函数，再调用A的析构函数。
#### 为什么默认的析构函数不是虚函数？  
那么既然基类的析构函数如此有必要被定义成虚函数，为何类的默认析构函数却是非虚函数呢？  
首先一点，语言设计者如此设计，肯定是有道理的。  
原来是因为，虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。  
这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。  
这样一说，问题就不言而喻了。当我们创建一个类时，系统默认我们不会将该类作为基类，所以就将默认的析构函数定义成非虚函数，这样就不会占用额外的内存空间。同时，系统也相信程序开发者在定义一个基类时，会显示地将基类的析构函数定义成虚函数，此时该类才会维护虚函数表和虚表指针。  

#### 请用简单的语言告诉我C++ 是什么？
C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。 其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一,支持类：类、封装、重载等特性!

#### C和C++的区别？  
c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。  

#### STL库用过吗，常用的STL容器有哪些，算法用过哪几个？  
STL包括两个部分：
容器和算法（重要的还有融合这两者的迭代器）
容器，即存放数据的地方（比如array等）
在STL中，容器分为两类：序列式容器和关联式容器。  
序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；  
关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。  
下面各选取一个作为说明。  
#### 这里涉及vector的扩容机制
vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。  
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。  
算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。  
迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

#### 底层实现原理
STL 众多容器中，vector 是最常用的容器之一，其底层所采用的数据结构非常简单，就只是一段连续的线性内存空间。  
通过分析 vector 容器的源代码不难发现，它就是使用 3 个迭代器（可以理解成指针）来表示的：  
```cpp
//_Alloc 表示内存分配器，此参数几乎不需要我们关心
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector{
    ...
protected:
    pointer _Myfirst;
    pointer _Mylast;
    pointer _Myend;
};
```
其中，_Myfirst 指向的是 vector 容器对象的起始字节位置；_Mylast 指向当前最后一个元素的末尾字节；_myend 指向整个 vector 容器所占用内存空间的末尾字节。
![](http://c.biancheng.net/uploads/allimg/191212/2-191212123P2Q5.gif)  

图 1 演示了以上这 3 个迭代器分别指向的位置。
如图 1 所示，通过这 3 个迭代器，就可以表示出一个已容纳 2 个元素，容量为 5 的 vector 容器。

在此基础上，将 3 个迭代器两两结合，还可以表达不同的含义，例如：  
_Myfirst 和 _Mylast 可以用来表示 vector 容器中目前已被使用的内存空间；  
_Mylast 和 _Myend 可以用来表示 vector 容器目前空闲的内存空间；  
_Myfirst 和 _Myend 可以用表示 vector 容器的容量。  
对于空的 vector 容器，由于没有任何元素的空间分配，因此 _Myfirst、_Mylast 和 _Myend 均为 null。  
通过灵活运用这 3 个迭代器，vector 容器可以轻松的实现诸如首尾标识、大小、容器、空容器判断等几乎所有的功能，比如：  
```cpp
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector{
public：
    iterator begin() {return _Myfirst;}
    iterator end() {return _Mylast;}
    size_type size() const {return size_type(end() - begin());}
    size_type capacity() const {return size_type(_Myend - begin());}
    bool empty() const {return begin() == end();}
    reference operator[] (size_type n) {return *(begin() + n);}
    reference front() { return *begin();}
    reference back() {return *(end()-1);}
    ...
};
```
vector扩大容量的本质
另外需要指明的是，当 vector 的大小和容量相等（size==capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：
完全弃用现有的内存空间，重新申请更大的内存空间；  
将旧内存空间中的数据，按原有顺序移动到新的内存空间中；  
最后将旧的内存空间释放。  
这也就解释了，为什么 vector 容器在进行扩容后，与其相关的指针、引用以及迭代器可能会失效的原因。  

由此可见，vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity>=size），以便后期使用。  
vector 容器扩容时，不同的编译器申请更多内存空间的量是不同的。以 VS 为例，它会扩容现有容器容量的 50%。  

使用reserve来避免不必要的重新分配（vector）  
reserve可以强迫容器把它的容量变为至少是n，前提是n不小于当前的大小。  


[条目十四《使用reserve来避免不必要的重新分配》](https://www.cnblogs.com/liangjf/p/10259684.html)  
使用vector和string的插入元素的时候，我们是不用担心内存问题的（只要不超过容器的max_size）。因为底层有分配子管理内存。在插入元素的时候，内存不够会发生像realloc的过程：

分配新的内存块,它有容器目前容量的几倍。在大部分实现中,vector和string的容量每次以2为因数增
长。也就是说,当容器必须扩展时,它们的容量每次翻倍。
把所有元素从容器的旧内存拷贝到它的新内存。
销毁旧内存中的对象。
回收旧内存
先看个例子
```cpp
vector<int> vec;
for(int i = 0; i < 10; i++)
{
    vec.push_back(i)
}
```
这个过程会发生最少4次重新分配内存的过程。再来看下一个重新分配内存涉及到哪些过程：

1.new操作-->malloc
2.拷贝操作
3.析构对象
4.释放内存
咋一看，一两次还可以接受，当插入的元素越来越多的时候，对性能的消耗是非常客观的。

上面的问题还只是其中一个问题，在插入元素时，重新分配内存会造成迭代器、指针和引用的失效。

为了优化这两个问题，在使用vector和string的时候，可以使用reserve函数。先引出四个关于容器大小和设置的成员函数：

size()———————获得容器的元素个数

capacity()———获得容器的容量

resize()—————强制设置容器的元素个数（参数大于当前大小，调用默认构造函数创建元素填充在尾部。小于当前大小，会析构并销毁多余的元素）

reserve()————强制设置容器的容量大小（参数小于现有的容量大小会忽略当前调用，大于会扩容。）

为了避免容器的不必要扩容而造成的消耗，在初始化容器的时候可以通过reserve()设置容器的容量大小，这样在插入元素的是够，只要当前的元素个数小于容量大小，都不会发生重新分配内存。这样也就不会发生迭代器、指针和引用失效等问题，也就没有多次拷贝，析构对象，释放内存的现象发生。
```cpp
vector<int> vec;
vec.reserve(15);
for(int i = 0; i < 10; i++)
{
    vec.push_back(i)
}
```
这个过程在reserve后插入元素不会发生重新分配内存过程。因为，插入的元素个数(10)小于容量的大小(15)。

可能有人说，在开始时设置过多的容量，那么不就相当于数组吗？浪费了剩余没用到内存，不用担心这个问题，我们可以等插入元素完毕的时候：

调用sesize()来修剪大小
使用swap()技巧。（vector tmp_vec(vec).swap(vec) 利用容器的拷贝构造不会复制空内存的原理，先创建一个纯净的临时容器，然后再交换容器内容，原来的容器就可以成为一个没有多余容量的容器，节省内存哦）




