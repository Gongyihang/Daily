# 第七章 类
类的基本思想是数据抽象和封装。
数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。
类的接口包括用户所能执行的操作。
类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用而无法访问实现部分。


# C++的关键字
## const关键字
[C++笔记 · C++关键字 - const](https://zhuanlan.zhihu.com/p/27919970)


## sizeof关键字
[C++ sizeof关键字的使用总结](https://blog.csdn.net/sinat_20265495/article/details/51622990)

**1.定义**
 
 sizeof是一个操作符（operator）。其作用是返回一个对象或类型所占的内存字节数。 其返回值类型为size_t。（size_t在头文件stddef.h中定义，它依赖于编译系统的值，一般定义为 typedef unsigned int size_t;）

**2.语法**
```c++
//sizeof有三种语法形式：
sizeof (object);  //sizeof (对象)
sizeof object;   //sizeof 对象
sizeof (type_name);  //sizeof (类型)
/*
对象可以是各种类型的变量，以及表达式
（一般sizeof不会对表达式进行计算）。
sizeof对对象求内存大小，最终都是转换为对对象的数据类型进行求值。
sizeof (表达式); //值为表达式的最终结果的数据类型的大小
*/
```
例子：
```c
int i;  
sizeof(int); //值为4  
sizeof(i); //值为4，等价于sizeof(int)  
sizeof i; //值为4  
sizeof(2); //值为4，等价于sizeof(int)，因为2的类型为int  
sizeof(2 + 3.14); //值为8，等价于sizeof(double)，因为此表达式的结果的类型为double  
char ary[sizeof(int) * 10]; //OK，编译无误  
```
**3.基本数据类型的sizeof**

这里的基本数据类型是指short、int、long、float、double这样的简单内置数据类型。
由于它们的内存大小是和系统相关的，所以在不同的系统下取值可能不同。

**4.结构体的sizeof**

结构体的sizeof涉及到字节对齐问题。

为什么需要字节对齐？

计算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多花指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，依次类推。

这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。
字节对齐的细节和编译器的实现相关，但一般而言，满足三个准则：

1） 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。

2） 结构体的每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节（internal adding）。

3） 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员后加上填充字节（trailing padding）。

注意：空结构体（不含数据成员）的sizeof值为1。

试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。

例子：
```c
struct S1
{
    char a;
    int b;
};
sizeof(S1);//值为8，字节对齐，在char之后会填充3个字节。
struct S2
{
    int b;
    char a;
};
sizeof(S2); //值为8，字节对齐，在char之后会填充3个字节。
struct S3
{
};
sizeof(S3); //值为1，空结构体也占内存。
```

**5.联合体的sizeof**
```c
/*结构体在内存组织上市顺序式的，联合体则是重叠式，各成员共享一段内存；所以整个联合体的sizeof也就是每个成员sizeof的最大值。
例子：
*/
union u  
{  
    int a;  
    float b;  
    double c;  
    char d;  
};  
sizeof(u); //值为8
```
**6.数组的sizeof**
```c
/*数组的sizeof值等于数组所占用的内存字节数。
注意：1）当字符数组表示字符串时，其sizeof值将’/0’计算进去。
2）当数组为形参时，其sizeof值相当于指针的sizeof值。
例子1：：
*/
char a[10];  
char n[] = "abc";   
cout<<"char a[10]"<<sizeof(a)<<endl;//数组，值为10  
cout<<"char n[] = /"abc/""<<sizeof(n)<<endl;
//字符串数组，将'/0'计算进去，值为4
void func(char a[3])  
{  
    int c = sizeof(a); //c = 4，因为这里a不在是数组类型，而是指针，相当于char *a。  
}  
void funcN(char b[])  
{  
    int cN = sizeof(b); //cN = 4，理由同上。  
}
```
**7.指针的sizeof**
```c
/*指针是用来记录另一个对象的地址，所以指针的内存大小当然就等于计算机内部地址总线的宽度。
在32位计算机中，一个指针变量的返回值必定是4。
指针变量的sizeof值与指针所指的对象没有任何关系。
例子：
*/
char *b = "helloworld";  
char *c[10];  
double *d;  
int **e;  
void (*pf)();    
cout<<"char *b = /"helloworld/"     "<<sizeof(b)<<endl;
//指针指向字符串，值为4  
cout<<"char *b                      "<<sizeof(*b)<<endl; 
//指针指向字符，值为1  
cout<<"double *d                    "<<sizeof(d)<<endl;
//指针，值为4  
cout<<"double *d                    "<<sizeof(*d)<<endl;
//指针指向浮点数，值为8  
cout<<"int **e                      "<<sizeof(e)<<endl;
//指针指向指针，值为4  
cout<<"char *c[10]                  "<<sizeof(c)<<endl;
//指针数组，值为40  
cout<<"void (*pf)();                "<<sizeof(pf)<<endl;
//函数指针，值为4  
```
**8.函数的sizeof**
```c
/*sizeof也可对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。
对函数求值的形式：sizeof(函数名(实参表))
注意：1）不可以对返回值类型为空的函数求值。
2）不可以对函数名求值。
3）对有参数的函数，在用sizeof时，须写上实参表。
例子：
*/
#include <iostream>  
using namespace std;  
float FuncP(int a, float b)  
{  
     return a + b;  
}  
int FuncNP()  
{  
     return 3;  
}  
void Func()  
{  
}  
int main()  
{  
    cout<<sizeof(FuncP(3, 0.4))<<endl; //OK，值为4，sizeof(FuncP(3,0.4))相当于sizeof(float)  
    cout<<sizeof(FuncNP())<<endl; //OK，值为4，sizeof(FuncNP())相当于sizeof(int)  
    /*cout<<sizeof(Func())<<endl; //error，sizeof不能对返回值为空类型的函数求值*/  
    /*cout<<sizeof(FuncNP)<<endl; //error，sizeof不能对函数名求值*/  
}     
```

# C++的多态  

一个对象具备多种形态，也可以理解为事物存在的多种体现形态。（ex：父类的引用类型变量指向了子类对象，或者是接口的引用类型变量指向了接口实现类的对象）  

虚函数就是用来处理多态的。  
动态多态的实现是, 父类的指针或引用, 调用父类或子类的同一个接口, 即同名虚函数, 如果子类实现了虚函数重写, 就可以实现多态, 实质上就是调用子类或父类的同一个接口, 实现不同的方法, 指向谁调谁

具体的实现是通过虚函数来实现的, C++中, 如果一个类中有虚函数, 那么类的对象模型中就会维护一个虚表指针,指向一个虚表, 虚表就是虚函数表, 是一个函数指针数组, 存储的是类中所有虚函数的函数指针, 当子类继承父类后, 子类也继承了父类的虚表, 如果子类对父类的同名虚函数重写, 子类会把重写了父类的虚函数的函数指针存储到自己的虚表中,  覆盖掉虚表中对应父类虚函数的函数指针

然后, 当父类的指针或引用调用虚函数时, 会在虚表中取出函数指针, 指向子类时, 取出的是子类的虚函数的函数指针, 指向父类时, 调用的是父类的虚函数的函数指针.

```cpp
#include <cstdlib>
#include <iostream>
#include <stdio.h>
 
using namespace std;
 
class Parent
{
    public:
        virtual void print()
        {
            printf("I am parent\n");
        }    
};
 
class Child : public Parent
{
    public:
        void print()
        {
            printf("I am Children\n");
        }    
};
 
void run(Parent *p)
{
    p->print();    
}
int main(int argc, char *argv[])
{
    Parent parent;
    Child child;
    
    run(&parent);
    run(&child);
    
    
    cout << "Press the enter key to continue ...";
    cin.get();
    return EXIT_SUCCESS;
}
```

多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数，从上例代码运行的结果看，系统成功的分辨出了对象的真实类型，成功的调用了各自的重载成员函数。  

虚函数的定义要遵循以下重要规则：   

1.如果虚函数在基类与派生类中出现，仅仅是名字相同，而形式参数不同，或者是返回类型不同，那么即使加上了virtual关键字，也是不会进行滞后联编的。 

2.只有类的成员函数才能说明为虚函数，因为虚函数仅适合用与有继承关系的类对象，所以普通函数不能说明为虚函数。 

3.静态成员函数不能是虚函数,因为静态成员函数的特点是不受限制于某个对象。 

4.内联(inline)函数不能是虚函数，因为内联函数不能在运行中动态确定位置。即使虚函数在类的内部定义定义，但是在编译的时候系统仍然将它看做是非内联的。 

5.构造函数不能是虚函数，因为构造的时候，对象还是一片位定型的空间，只有构造完成后，对象才是具体类的实例。 

6.析构函数可以是虚函数,而且通常声名为虚函数。 

同时需要了解多态的特性的virtual修饰，不单单对基类和派生类的普通成员 函数有必要，而且对于基类和派生类的析构函数同样重要！！！

# C++多态  
[C++ 多态详解](https://www.cnblogs.com/dormant/p/5223215.html)  

# C++构造函数和析构函数  
构造函数的作用：用于新建对象的初始化工作。

析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等。

每当创建对象时，需要添加初始化代码时，则需要定义自己的构造函数；

而对象撤销时，需要自己添加清理工作的代码时，则需要定义自己的析构函数。

#### 为什么要把父类的析构函数定义成虚函数?
写成虚的是为了在实现多态的时候不造成内存泄露,如果基类析构函数前不加vitual，派生类对象被销毁后，只会调用基类的析构函数，而不会去调用派生类的析构函数。 

在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。  

#### 深拷贝和浅拷贝的区别  
深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。  
假设B复制了A，修改A的时候，看B是否发生变化：  

如果B跟着也变了，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）  

如果B没有改变，说明是深拷贝，自食其力！（修改堆内存中的不同的值）  

浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，  

深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，  
使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。  

浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。  

深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。  

##### 如果一个函数传入一个对象，那么这是浅拷贝还是深拷贝？  
如果使用的是引用或指针不会发生拷贝，如果传入的类没有实现拷贝构造函数则是浅拷贝，如果实现了拷贝构造函数则看实现的拷贝构造函数是浅拷贝还是深拷贝。  

# C语言里的指针是什么？  
指针是一种保存变量地址的变量。实际上指针不一定是变量，也有常量指针，不过一般都说指针是指针变量的简称。所以上述表达没有什么问题。  

我们知道，基本的数据类型包括int、char和double等。在C语言中，还有一种类型为指针类型~。指针类型不是单独存在的，它是由其他类型派生而来的。也就是说，有个指针变量，其类型为，“指向int的指针类型”或者“指向double的指针类型”。因为先有了“指针类型”，所以有了“指针类型的变量”和“指针类型的值”。“指针类型”是类型，所以和int类型、double类型一样，存在“指针类型的变量”和“指针类型的值”。但是要命的是，“指针类型”、“指针类型的变量”和“指针类型的值”经常被简单(naive)的统称为“指针”。  
这里的“指针类型的值”实际上也就是内存的地址。

### 指针常量与常量指针  
const关键字
指针常量和常量指针都离不开const关键字，我们先来了解一下什么是const关键字，const被用来定义常量，如果将一个变量加上const关键字，则被修饰的变量的值将无法改变。这个变量的值只能被访问，无法被修改。const关键字可以修饰变量或者指针。

下面是const修饰变量的用法：

const int a = 6;

或者 int const a = 6；

此时变量a的值无法改变，只能访问，不能改写。

指针常量  
指针本身是一个常量，不能更改指针指向的地址，只能更改指针指向地址的值。  
常量指针  
常量指针指的是一个常量，所以指针指向的值是不能改变的，但是指针指向的地址是可以改变的。  
区别：  
注意指针常量和常量指针的区别，指针常量只能改变值，不能改变地址，常量指针只能改变地址，不能改变值。  
如果要想值和地址都不改变可以同时在前后都加上const关键字。  

